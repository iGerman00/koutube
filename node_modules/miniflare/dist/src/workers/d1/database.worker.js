var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  for (var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target, i = decorators.length - 1, decorator; i >= 0; i--)
    (decorator = decorators[i]) && (result = (kind ? decorator(target, key, result) : decorator(result)) || result);
  return kind && result && __defProp(target, key, result), result;
};

// packages/miniflare/src/workers/d1/database.worker.ts
import assert from "node:assert";
import {
  HttpError,
  MiniflareDurableObject,
  POST,
  all,
  get,
  viewToBuffer
} from "miniflare:shared";
import { z } from "miniflare:zod";
var D1ValueSchema = z.union([
  z.number(),
  z.string(),
  z.null(),
  z.number().array()
]), D1QuerySchema = z.object({
  sql: z.string(),
  params: z.array(D1ValueSchema).nullable().optional()
}), D1QueriesSchema = z.union([D1QuerySchema, z.array(D1QuerySchema)]), served_by = "miniflare.db", D1Error = class extends HttpError {
  constructor(cause) {
    super(500);
    this.cause = cause;
  }
  toResponse() {
    let response = { success: !1, error: typeof this.cause == "object" && this.cause !== null && "message" in this.cause && typeof this.cause.message == "string" ? this.cause.message : String(this.cause) };
    return Response.json(response);
  }
};
function convertParams(params) {
  return (params ?? []).map(
    (param) => (
      // If `param` is an array, assume it's a byte array
      Array.isArray(param) ? viewToBuffer(new Uint8Array(param)) : param
    )
  );
}
function convertResults(rows) {
  return rows.map(
    (row) => Object.fromEntries(
      Object.entries(row).map(([key, value]) => {
        let normalised;
        return value instanceof ArrayBuffer ? normalised = Array.from(new Uint8Array(value)) : normalised = value, [key, normalised];
      })
    )
  );
}
function sqlStmts(db) {
  return {
    getChanges: db.prepare(
      "SELECT total_changes() AS totalChanges, last_insert_rowid() AS lastRowId"
    )
  };
}
var D1DatabaseObject = class extends MiniflareDurableObject {
  #stmts;
  constructor(state, env) {
    super(state, env), this.#stmts = sqlStmts(this.db);
  }
  #changes() {
    let changes = get(this.#stmts.getChanges());
    return assert(changes !== void 0), changes;
  }
  #query = (query) => {
    let beforeTime = performance.now(), beforeSize = this.state.storage.sql.databaseSize, beforeChanges = this.#changes(), params = convertParams(query.params ?? []), cursor = this.db.prepare(query.sql)(...params), results = convertResults(all(cursor)), afterTime = performance.now(), afterSize = this.state.storage.sql.databaseSize, afterChanges = this.#changes(), duration = afterTime - beforeTime, changes = afterChanges.totalChanges - beforeChanges.totalChanges, hasChanges = changes !== 0, lastRowChanged = afterChanges.lastRowId !== beforeChanges.lastRowId, changed = hasChanges || lastRowChanged || afterSize !== beforeSize;
    return {
      success: !0,
      results,
      meta: {
        served_by,
        duration,
        changes,
        last_row_id: afterChanges.lastRowId,
        changed_db: changed,
        size_after: afterSize
      }
    };
  };
  #txn(queries) {
    if (queries = queries.filter(
      (query) => query.sql.replace(/^\s+--.*/gm, "").trim().length > 0
    ), queries.length === 0) {
      let error = new Error("No SQL statements detected.");
      throw new D1Error(error);
    }
    try {
      return this.state.storage.transactionSync(() => queries.map(this.#query));
    } catch (e) {
      throw new D1Error(e);
    }
  }
  queryExecute = async (req) => {
    let queries = D1QueriesSchema.parse(await req.json());
    return Array.isArray(queries) || (queries = [queries]), Response.json(this.#txn(queries));
  };
};
__decorateClass([
  POST("/query"),
  POST("/execute")
], D1DatabaseObject.prototype, "queryExecute", 2);
export {
  D1DatabaseObject,
  D1Error
};
//# sourceMappingURL=database.worker.js.map
